{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Big Chess Analysis by team DataWizards","text":""},{"location":"#description","title":"DESCRIPTION","text":"<p>The following project is a Big Chess Analysis using the chess.com API and API Wrapper.</p> <p>This project is open-source on Github, with published docs at Documentation.</p> <p>Looking to contribute? Visit CONTRIBUTING for more details.</p>"},{"location":"#introduction","title":"INTRODUCTION","text":"<p>Learn more about the community of players you or your opponent's are part of in Chess.com! Deep-dive into the chess.com network and identify &amp; report unusual anomalies in games or players!</p> <p>This project enables an interactive graph of chess.com players, pulling player and game data along the way to analyze and identify anomalies.</p> <p>Deep dive analysis approaches can be found in <code>notebooks/</code>.</p>"},{"location":"#installation","title":"INSTALLATION","text":"<p>No installation required! Simply visit our site and start exploring.</p> <p>If local install is preferred:</p> <ul> <li><code>poetry</code> is highly recommended. Follow Poetry Installation for installation.</li> <li><code>poetry install</code> to install &amp; create a local virtual environment for the project.</li> <li>Alternatively, a <code>requirements.txt</code> is generated for <code>pip</code>.</li> </ul>"},{"location":"#execution","title":"EXECUTION","text":"<p>Execution not required! Simply visit our site and start exploring.</p> <p>If local execution is preferred:</p> <ul> <li><code>poetry</code> is highly recommended to enable <code>poetry run</code>.</li> <li>Alternatively, leverage <code>requirements.txt</code> &amp; <code>python -m venv</code>.</li> <li><code>make serve-dev</code> to launch the webapp on localhost (using Dash)   -- Alternatively <code>poetry run python dashapp/main.py</code>   -- Alternatively <code>make serve</code> to launch with gunicorn on 127.0.0.1:8080</li> </ul>"},{"location":"#exploration","title":"Exploration","text":"<p>Visit our site to get started. There you will be greeted with inputs: Username, Date, and Depth. Please input a chess.com username to begin (modify date and depth to your preference).</p> <p>Easter-Egg: You can skip the inputs and simply generate the graph right away!</p> <p>Once the graph is loaded, you're welcome to click on graph'ed nodes, and explore the space further.</p> <p>If struggling to find good inputs. This project was tested using:</p> <ul> <li>Username: fabianocaruana</li> <li>Year: 2024</li> <li>Month: 10</li> <li>Depth: 3 (Optional)</li> </ul>"},{"location":"#analytics","title":"Analytics","text":"<p>Analytics of the graph is generated live as the graph adapts. Review the analytics, and consider reporting anomalies to chess.com!</p> <p>More in-depth approaches can be found in <code>notebooks</code>.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>The following provides a detailed explanation on how to contribute to this project.</p>"},{"location":"CONTRIBUTING/#setupinstallation","title":"Setup/Installation","text":"<p>This project leverages poetry as its package &amp; environment management. To get started, simply run <code>poetry install --with dev</code> to setup and install the necessary dependencies.</p> <p>For further information on installing &amp; using poetry, visit poetry.</p>"},{"location":"CONTRIBUTING/#test","title":"Test","text":"<p>This project leverages various tests, formatters, linters, and more. To facilitate the execution of these tests, the following makefile target was made: <code>make tests</code></p> <p>Execute <code>make tests</code> to ensure the project was cloned successfully, and leverage it often to test contributions.</p>"},{"location":"CONTRIBUTING/#serve","title":"Serve","text":"<p>This project leverages Plotly Dash to serve a web app.</p> <p>Execute <code>make serve-dev</code> to start running a local server of the app for testing. Or execute <code>make serve</code> to serve the site similar to production.</p>"},{"location":"CONTRIBUTING/#deploy","title":"Deploy","text":"<p>This project is deployed on GCP. Once <code>gcloud</code> is installed and configured locally, execute <code>make deploy</code> to deploy the app on GCP.</p>"},{"location":"about/","title":"About Us","text":""},{"location":"about/#who-are-we","title":"Who are we?","text":"<p>We are a small team of students enrolled in the Georgia Tech Online Master of Science in Analytics (OMSA) program, currently taking CSE 6242: Data and Visual Analytics. Our backgrounds are diverse, but we're united by a shared passion for data science, analytics, and the power of data-driven insights.</p>"},{"location":"about/#why-this","title":"Why this?","text":"<p>This project is part of our coursework for CSE 6242, where we've been tasked with exploring data analysis and visualization techniques on big data. For our project, we're leveraging the chess.com API to detect anomalies in player behavior and performance. By using graph modeling, we're able to map player interactions, analyze performance trends, and discover potential irregularities, adding valuable insights into the online chess communities.</p>"},{"location":"about/#thank-you","title":"Thank you!","text":"<p>Thank you for taking the time to explore our work!</p>"},{"location":"anomaly_detection/","title":"Anomaly Detection","text":"<p>Oops... this page is under construction. Please come back soon!</p>"},{"location":"reference/cache/","title":"Cache","text":""},{"location":"reference/cache/#cache.cache","title":"<code>cache(func)</code>","text":"<p>Cache the results of a function. JSON logic can be replaced with DB solutions (i.e. MongoDB)</p> Source code in <code>cache/main.py</code> <pre><code>def cache(func):\n    \"\"\"\n    Cache the results of a function.\n    JSON logic can be replaced with DB solutions (i.e. MongoDB)\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if IS_GCP:  # Disable cache on GCP\n            return func(*args, **kwargs)\n        cache_key = f\"{func.__name__}/{'_'.join(map(str, args))}.json\"\n        cache_path = CACHE_DIR / cache_key\n        cache_path.parent.mkdir(exist_ok=True)\n\n        if cache_path.exists():\n            try:\n                return load_json(cache_path)\n            except json.JSONDecodeError:\n                print(f\"Error loading cache for {cache_path}. Recomputing...\")\n\n        if data := func(*args, **kwargs):\n            save_json(data, cache_path)\n            return data\n        return None\n\n    return wrapper\n</code></pre>"},{"location":"reference/dashapp/","title":"Dash App","text":""},{"location":"reference/dashapp/#dashapp.graph.add_opponents_with_depth","title":"<code>add_opponents_with_depth(graph, username, year, month, depth, player=None)</code>","text":"<p>Recursively add opponents to the graph up to a specified depth.</p> Source code in <code>dashapp/graph.py</code> <pre><code>def add_opponents_with_depth(\n    graph: nx.Graph,\n    username: str,\n    year: Optional[int],\n    month: Optional[int],\n    depth: int,\n    player: Optional[PlayerNode] = None,\n) -&gt; nx.Graph:\n    \"\"\"Recursively add opponents to the graph up to a specified depth.\"\"\"\n\n    async def recursive_add(\n        graph: nx.Graph, username: str, current_depth: int, player: Optional[PlayerNode]\n    ):\n        if current_depth &gt; depth:\n            return\n\n        _, opponents_node = await _add_opponents_async(\n            graph, username, year, month, player\n        )\n\n        for opponent, node in opponents_node.items():\n            if node:\n                await recursive_add(graph, opponent, current_depth + 1, node)\n\n    asyncio.run(recursive_add(graph, username, 1, player))\n\n    return graph\n</code></pre>"},{"location":"reference/dashapp/#dashapp.graph.create_figure","title":"<code>create_figure(graph)</code>","text":"<p>Create a Plotly figure from a NetworkX graph.</p> Source code in <code>dashapp/graph.py</code> <pre><code>def create_figure(graph: nx.Graph):\n    \"\"\"Create a Plotly figure from a NetworkX graph.\"\"\"\n    pos = nx.fruchterman_reingold_layout(graph)  # May alter if needed\n\n    min_weight = 0\n    max_weight = max(\n        (data.get(\"weight\", 1) for _, _, data in graph.edges(data=True)), default=1\n    )\n    cmap = plt.get_cmap(\"plasma\")\n\n    edges = []\n    for edge in graph.edges(data=True):\n        x0, y0 = pos[edge[0]]\n        x1, y1 = pos[edge[1]]\n\n        weight = edge[-1].get(\"weight\", 1)\n\n        if max_weight &gt; min_weight:\n            normalized_weight = (weight - min_weight) / (max_weight - min_weight)\n        else:\n            normalized_weight = 0\n        color = cmap(normalized_weight)\n        r, g, b = (int(c * 255) for c in color[:3])\n        edge_trace = go.Scatter(\n            x=[x0, x1],\n            y=[y0, y1],\n            line=dict(\n                width=2,\n                color=f\"rgba({r}, {g}, {b}, 1)\",\n            ),\n            mode=\"lines\",\n            showlegend=False,\n            hoverinfo=\"none\",\n        )\n        edges.append(edge_trace)\n\n    fig = go.Figure(data=edges)\n\n    node_x = [pos[node][0] for node in graph.nodes()]\n    node_y = [pos[node][1] for node in graph.nodes()]\n    node_text = [str(node) for node in graph.nodes()]\n    ratings = [graph.nodes[node].get(\"rating\", 0) for node in graph.nodes()]\n    norm_ratings = (ratings - np.min(ratings)) / max(\n        1, (np.max(ratings) - np.min(ratings))\n    )\n    node_colors = cmap(norm_ratings)\n\n    nodes = go.Scatter(\n        x=node_x,\n        y=node_y,\n        mode=\"markers\",\n        hoverinfo=\"text\",\n        text=node_text,\n        marker=dict(\n            size=15,\n            color=[\n                f\"rgba({int(c[0]*255)}, {int(c[1]*255)}, {int(c[2]*255)}, 1)\"\n                for c in node_colors\n            ],\n        ),\n        showlegend=False,\n    )\n\n    fig.add_trace(nodes)\n\n    fig.update_layout(\n        showlegend=False,\n        hovermode=\"closest\",\n        margin=dict(b=0, l=0, r=0, t=0),\n        xaxis=dict(showgrid=False, zeroline=False, visible=False),\n        yaxis=dict(showgrid=False, zeroline=False, visible=False),\n        width=None,\n        height=None,\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/dashapp/#dashapp.graph.data_to_graph","title":"<code>data_to_graph(graph_data)</code>","text":"<p>Convert stored data back to a graph.</p> Source code in <code>dashapp/graph.py</code> <pre><code>def data_to_graph(graph_data):\n    \"\"\"Convert stored data back to a graph.\"\"\"\n    graph = nx.Graph()\n    graph.add_nodes_from(graph_data[\"nodes\"])\n    graph.add_edges_from(graph_data[\"edges\"])\n    return graph\n</code></pre>"},{"location":"reference/dashapp/#dashapp.graph.graph_to_data","title":"<code>graph_to_data(graph)</code>","text":"<p>Convert the graph to store both nodes and edges.</p> Source code in <code>dashapp/graph.py</code> <pre><code>def graph_to_data(graph: nx.Graph):\n    \"\"\"Convert the graph to store both nodes and edges.\"\"\"\n    data = {\n        \"nodes\": list(graph.nodes(data=True)),\n        \"edges\": list(graph.edges(data=True)),\n    }\n\n    return data\n</code></pre>"},{"location":"reference/dashapp/#dashapp.graph.initialize_and_update_graph","title":"<code>initialize_and_update_graph(n_clicks, click_data, username, year, month, depth, graph_data)</code>","text":"<p>Initialize and update the graph when the initialize button is clicked.</p> Source code in <code>dashapp/graph.py</code> <pre><code>@app.callback(\n    [\n        Output(\"network-graph\", \"figure\"),\n        Output(\"graph-data\", \"data\"),\n        Output(\"graph-error\", \"displayed\"),\n        Output(\"graph-error\", \"message\"),\n    ],\n    [\n        Input(\"init-button\", \"n_clicks\"),\n        Input(\"network-graph\", \"clickData\"),\n    ],\n    [\n        State(\"username-input\", \"value\"),\n        State(\"year-input\", \"value\"),\n        State(\"month-input\", \"value\"),\n        State(\"depth-input\", \"value\"),\n        State(\"graph-data\", \"data\"),\n    ],\n)\ndef initialize_and_update_graph(\n    n_clicks, click_data, username, year, month, depth, graph_data\n):\n    \"\"\"Initialize and update the graph when the initialize button is clicked.\"\"\"\n\n    def initialize_new_graph(username, depth):\n        \"\"\"Initializes a new graph with given username and depth.\"\"\"\n        user = username or \"fabianocaruana\"\n        graph = initialize_graph(user, year, month, depth)\n        print(f\"Initialized graph with {username}.\")\n        return graph\n\n    def update_graph_from_click(\n        graph: nx.Graph, click_data: dict, year: Optional[int], month: Optional[int]\n    ):\n        \"\"\"Updates the graph with additional data based on clicked node.\"\"\"\n        clicked_node = click_data[\"points\"][0][\"text\"]\n        print(f\"Clicked node: {clicked_node}\")\n        player = PlayerNode(**dict(graph.nodes(data=True)).get(clicked_node) or {})\n        graph, _ = _add_opponents(graph, clicked_node, year, month, player=player)\n\n    def get_default_response(graph):\n        \"\"\"Creates default responses when no error occurs.\"\"\"\n        return create_figure(graph), graph_to_data(graph), False, \"\"\n\n    def init_button_clicked():\n        ctx = callback_context\n        return ctx.triggered and ctx.triggered[0][\"prop_id\"] == \"init-button.n_clicks\"\n\n    try:\n        if graph_data is None or (init_button_clicked()):\n            try:\n                graph = initialize_new_graph(username, depth)\n            except ValueError:\n                graph = initialize_new_graph(username, 0)\n            return get_default_response(graph)\n\n        graph = data_to_graph(graph_data)\n\n        if click_data is not None:\n            update_graph_from_click(graph, click_data, year, month)\n\n        return get_default_response(graph)\n\n    except ValueError as e:\n        print(e)\n        figure = create_figure(graph) if graph else {}\n        data = graph_to_data(graph) if graph else None\n        return figure, data, True, str(e)\n</code></pre>"},{"location":"reference/dashapp/#dashapp.graph.initialize_graph","title":"<code>initialize_graph(username='fabianocaruana', year=None, month=None, depth=1)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Player to intialize with. Defaults to \"fabianocaruana\".</p> <code>'fabianocaruana'</code> <code>depth</code> <code>int</code> <p>Depth of the graph. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: NetworkX graph object.</p> Source code in <code>dashapp/graph.py</code> <pre><code>def initialize_graph(\n    username: str = \"fabianocaruana\",\n    year: Optional[int] = None,\n    month: Optional[int] = None,\n    depth: int = 1,\n) -&gt; nx.Graph:\n    \"\"\"_summary_\n\n    Args:\n        username (str, optional): Player to intialize with. Defaults to \"fabianocaruana\".\n        depth (int, optional): Depth of the graph. Defaults to 1.\n\n    Returns:\n        nx.Graph: NetworkX graph object.\n    \"\"\"\n    graph = nx.Graph()\n    player = get_player_data(username)\n    graph = add_node(graph, player)\n    graph = add_opponents_with_depth(graph, username, year, month, depth, player=player)\n    return graph\n</code></pre>"},{"location":"reference/extraction/","title":"Extraction","text":""},{"location":"reference/extraction/#extraction.fetch_archive_games","title":"<code>fetch_archive_games(username)</code>","text":"<p>Fetch the archive games of a player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the player.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of games the player has played.</p> Source code in <code>extraction/main.py</code> <pre><code>def fetch_archive_games(username: str) -&gt; list[dict]:\n    \"\"\"Fetch the archive games of a player.\n\n    Args:\n        username (str): The username of the player.\n\n    Returns:\n        list[dict]: A list of games the player has played.\n    \"\"\"\n\n    games = []\n    for url in get_player_game_archives(username)[\"archives\"]:\n        year = url.split(\"/\")[-2]\n        month = url.split(\"/\")[-1]\n        games += get_player_games_by_month(username, year, month)[\"games\"]\n\n    return games\n</code></pre>"},{"location":"reference/extraction/#extraction.fetch_player_data","title":"<code>fetch_player_data(username)</code>  <code>async</code>","text":"<p>Fetch the player data for a given username asynchronously.</p> Source code in <code>extraction/main.py</code> <pre><code>async def fetch_player_data(username: str) -&gt; Optional[PlayerNode]:\n    \"\"\"Fetch the player data for a given username asynchronously.\"\"\"\n    return await asyncio.to_thread(get_player_data, username)\n</code></pre>"},{"location":"reference/extraction/#extraction.get_opponents_and_games_by_month","title":"<code>get_opponents_and_games_by_month(username, year=None, month=None)</code>","text":"<p>Get opponents and game details for a player by month.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the player.</p> required <code>year</code> <code>Optional[int]</code> <p>The year to filter by. Defaults to None.</p> <code>None</code> <code>month</code> <code>Optional[int]</code> <p>The month to filter by. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[GameEdge]]</code> <p>Dict[str, List[GameEdge]]: A dictionary with opponent usernames as keys and lists of GameEdge objects as values.</p> Source code in <code>extraction/main.py</code> <pre><code>def get_opponents_and_games_by_month(\n    username: str, year: Optional[int] = None, month: Optional[int] = None\n) -&gt; Dict[str, List[GameEdge]]:\n    \"\"\"Get opponents and game details for a player by month.\n\n    Args:\n        username (str): The username of the player.\n        year (Optional[int], optional): The year to filter by. Defaults to None.\n        month (Optional[int], optional): The month to filter by. Defaults to None.\n\n    Returns:\n        Dict[str, List[GameEdge]]: A dictionary with opponent usernames as keys and lists of GameEdge objects as values.\n    \"\"\"\n    if year is None:\n        year = datetime.now().year\n    if month is None:\n        month = datetime.now().month\n\n    try:\n        games_data = get_player_games_by_month(username, year, month).get(\"games\", [])\n    except ChessDotComError as exc:\n        if exc.status_code == 0:\n            print(\n                f\"No games found for {username} in {year}-{month}. {year}-{month} is in the future.\"\n            )\n            return {}\n        else:\n            raise\n    opponents_games: Dict[str, List[GameEdge]] = {}\n\n    for game in games_data:\n        is_white = game[\"white\"][\"username\"] == username\n        opponent_username = (\n            game[\"black\"][\"username\"] if is_white else game[\"white\"][\"username\"]\n        )\n\n        game_edge = GameEdge(\n            pgn=game.get(\"pgn\", \"\"),\n            time_control=game.get(\"time_control\", \"\"),\n            time_class=game.get(\"time_class\", \"\"),\n            rules=game.get(\"rules\", \"\"),\n            accuracies=game.get(\"accuracies\", {}),\n            eco_code=game.get(\"eco\", \"\"),\n            white=PlayerDetails(\n                username=game[\"white\"][\"username\"],\n                rating=game[\"white\"].get(\"rating\", 0),\n                result=game[\"white\"][\"result\"],\n                uid=game[\"white\"][\"uuid\"],\n            ),\n            black=PlayerDetails(\n                username=game[\"black\"][\"username\"],\n                rating=game[\"black\"].get(\"rating\", 0),\n                result=game[\"black\"][\"result\"],\n                uid=game[\"black\"][\"uuid\"],\n            ),\n            start_time=game.get(\"start_time\", 0),\n            end_time=game.get(\"end_time\", 0),\n        )\n\n        if opponent_username not in opponents_games:\n            opponents_games[opponent_username] = []\n        opponents_games[opponent_username].append(game_edge)\n\n    if not opponents_games:\n        raise ValueError(\n            f\"No opponents found for {username} in {year}-{month}.\\nConsider a different user or date.\"\n        )\n\n    return opponents_games\n</code></pre>"},{"location":"reference/extraction/#extraction.get_player_data","title":"<code>get_player_data(username)</code>","text":"<p>Get the player data for a given username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the player.</p> required <p>Returns:</p> Name Type Description <code>PlayerNode</code> <code>Optional[PlayerNode]</code> <p>The player node object.</p> Source code in <code>extraction/main.py</code> <pre><code>def get_player_data(username: str) -&gt; Optional[PlayerNode]:\n    \"\"\"Get the player data for a given username.\n\n    Args:\n        username (str): The username of the player.\n\n    Returns:\n        PlayerNode: The player node object.\n    \"\"\"\n    try:\n        profile = get_player_profile(username).get(\"player\")\n    except ChessDotComError as exc:\n        print(f\"Error fetching profile for {username}: {exc}\")\n        return None\n    if not profile:\n        print(f\"Profile not found for {username}\")\n        return None\n\n    stats = get_player_stats(username).get(\"stats\").get(GAME_TYPE)\n    if stats is None:\n        return None\n    return PlayerNode(\n        uid=profile.get(\"player_id\"),\n        name=profile.get(\"name\"),\n        username=profile.get(\"username\"),\n        country=profile.get(\"country\").split(\"/\")[-1],\n        rating=stats.get(\"last\", {}).get(\"rating\", 0),\n    )\n</code></pre>"},{"location":"reference/network/","title":"Network","text":""},{"location":"reference/network/#network.GameEdge","title":"<code>GameEdge</code>  <code>dataclass</code>","text":"<p>Dataclass representing an edge between two players.</p> Source code in <code>network/main.py</code> <pre><code>@dataclass\nclass GameEdge:\n    \"\"\"Dataclass representing an edge between two players.\"\"\"\n\n    pgn: str\n    time_control: str\n    time_class: str\n    rules: str\n    accuracies: Dict[str, float]\n    eco_code: str\n\n    white: PlayerDetails\n    black: PlayerDetails\n\n    start_time: int\n    end_time: int\n    duration: Optional[int] = field(init=False)\n\n    def __post_init__(self):\n        self.duration = self.end_time - self.start_time\n</code></pre>"},{"location":"reference/network/#network.PlayerDetails","title":"<code>PlayerDetails</code>  <code>dataclass</code>","text":"<p>Dataclass representing details about a player in a match.</p> Source code in <code>network/main.py</code> <pre><code>@dataclass\nclass PlayerDetails:\n    \"\"\"Dataclass representing details about a player in a match.\"\"\"\n\n    uid: int\n    username: str\n    rating: int\n    result: str\n</code></pre>"},{"location":"reference/network/#network.PlayerNode","title":"<code>PlayerNode</code>  <code>dataclass</code>","text":"<p>Dataclass to represent a player node in the graph.</p> Source code in <code>network/main.py</code> <pre><code>@dataclass\nclass PlayerNode:\n    \"\"\"Dataclass to represent a player node in the graph.\"\"\"\n\n    uid: int\n    name: str\n    username: str\n    country: str\n    rating: int\n</code></pre>"},{"location":"reference/network/#network.add_edge","title":"<code>add_edge(graph, node1, node2, edge_data=None)</code>","text":"<p>Add an edge between two nodes if it doesn't already exist.</p> Source code in <code>network/main.py</code> <pre><code>def add_edge(\n    graph: nx.Graph,\n    node1: PlayerNode | None,\n    node2: PlayerNode | None,\n    edge_data: List[GameEdge] | None = None,\n) -&gt; nx.Graph:\n    \"\"\"Add an edge between two nodes if it doesn't already exist.\"\"\"\n    if node1 is None or node2 is None or edge_data is None:\n        print(\"Cannot add edge with missing nodes or edge data.\")\n        return graph\n    if node1.username not in graph:\n        graph = add_node(graph, node1)\n    if node2.username not in graph:\n        graph = add_node(graph, node2)\n    if not graph.has_edge(node1.username, node2.username):\n        weight = abs(node1.rating - node2.rating)\n        graph.add_edge(\n            node1.username,\n            node2.username,\n            weight=weight,\n            data=[asdict(edge) for edge in edge_data],\n        )\n    else:\n        edge = graph[node1.username][node2.username]\n        edge[\"data\"].extend([asdict(edge) for edge in edge_data])\n    return graph\n</code></pre>"},{"location":"reference/network/#network.add_node","title":"<code>add_node(graph, node)</code>","text":"<p>Add a node to the graph if it doesn't already exist.</p> Source code in <code>network/main.py</code> <pre><code>def add_node(graph: nx.Graph, node: PlayerNode | None) -&gt; nx.Graph:\n    \"\"\"Add a node to the graph if it doesn't already exist.\"\"\"\n    if node is not None and node.username not in graph:\n        graph.add_node(node.username, **asdict(node))\n    return graph\n</code></pre>"}]}